<!DOCTYPE html>
<html>
    <head>
        <title>Clock events</title>
        <script type="module">

import { sign } from "../../lib/util.js";
import { on } from "../../lib/events.js";
import { ManualClock } from "../../lib/clock.js";
import { test, skip } from "../test.js";
import { pendingUpdate } from "./util.js";

test("Callback parameters", t => {
    const clock = ManualClock.create();
    let check = false;
    clock.scheduler.at((updateTime, from, to) => {
        t.equal(updateTime, 7, "callback updateTime");
        t.equal(from, 0, "callback interval (from)");
        t.equal(to, 17, "callback interval (to)");
        check = true;
    }, 7);

    clock.start();
    clock.tick.advance(17);
    t.equal(check, true, "callback parameters were as expected");
});

test("Going forward through several events", t => {
    const clock = ManualClock.create();
    const events = [false, false, false];
    for (let i = 0; i < events.length; ++i) {
        clock.scheduler.at(updateTime => { events[i] = updateTime; }, i)
    }

    clock.start();
    clock.tick.advance(1);
    t.equal(events[0], 0, "event happened at 0");
    t.equal(events[1], 1, "event happened at 1");
    t.equal(events[2], false, "event has not happened yet at 2");
    clock.tick.advance(1);
    t.equal(events[2], 2, "event happened at 2");
});

test("Going backward", t => {
    const clock = ManualClock.create();
    const events = [false, false, false];
    for (let i = 0; i < events.length; ++i) {
        clock.scheduler.at((updateTime, from, to) => {
            events[i] = updateTime * sign(to - from);
        }, i + 1)
    }

    clock.start();
    clock.tick.advance(3);
    t.equal(events[0], 1, "event happened at 1");
    t.equal(events[1], 2, "event happened at 2");
    t.equal(events[2], 3, "event happened at 3");
    clock.tick.advance(-3);
    t.equal(events[0], -1, "event happened again at 1");
    t.equal(events[1], -2, "event happened again at 2");
    t.equal(events[2], 3, "event did not happen again at 3");
});

test("Repeating event", t => {
    const clock = ManualClock.create();
    const iterations = [];
    clock.scheduler.every(updateTime => { iterations.push(updateTime); }, 5, 3);

    clock.start();
    clock.tick.advance(7);
    t.equal(iterations, [3], "first update");
    clock.tick.advance(7);
    t.equal(iterations, [3, 8, 13], "second update");
    clock.tick.advance(-7);
    t.equal(iterations, [3, 8, 13, 13, 8], "backward update");
});

test("Set time when running", t => {
    const clock = ManualClock.create();
    const iterations = [];
    clock.scheduler.every(updateTime => { iterations.push(updateTime); }, 5, 3);

    clock.start();
    clock.tick.advance(7);
    t.equal(iterations, [3], "first update");
    clock.setTime(12);
    clock.tick.advance(7);
    t.equal(iterations, [3, 8, 13, 18], "second update; advanced");
});

test("Set time when running (rate=0)", t => {
    const clock = ManualClock.create();
    const iterations = [];
    clock.scheduler.every(updateTime => { iterations.push(updateTime); }, 5, 3);

    clock.start();
    clock.tick.advance(7);
    t.equal(iterations, [3], "first update");
    clock.setRate(0);
    clock.setTime(12);
    clock.tick.advance(7);
    t.equal(iterations, [3, 8], "second update; advanced");
});

test("Advance a running clock", t => {
    const clock = ManualClock.create();
    const iterations = [];
    clock.scheduler.every(updateTime => { iterations.push(updateTime); }, 5, 3);

    clock.start();
    clock.tick.advance(7);
    t.equal(iterations, [3], "first update");
    clock.advance(5);
    clock.tick.advance(7);
    t.equal(iterations, [3, 8, 13, 18], "second update; advanced");
});

test("Advance a running clock (rate=0)", t => {
    const clock = ManualClock.create();
    const iterations = [];
    clock.scheduler.every(updateTime => { iterations.push(updateTime); }, 5, 3);

    clock.start();
    clock.tick.advance(7);
    t.equal(iterations, [3], "first update");
    clock.setRate(0);
    clock.advance(5);
    clock.tick.advance(7);
    t.equal(iterations, [3, 8], "second update; advanced");
});

test("Skip with a running clock", t => {
    const clock = ManualClock.create();
    const iterations = [];
    clock.scheduler.every(updateTime => { iterations.push(updateTime); }, 5, 3);

    clock.start();
    clock.tick.advance(7);
    t.equal(iterations, [3], "first update");
    clock.skip(6);
    clock.tick.advance(7);
    t.equal(iterations, [3, 13, 18], "second update; advanced");
});

test("Start notification", t => {
    const clock = ManualClock.create();
    let updateNotification = null;
    on(clock, "start", e => { updateNotification = e; });

    clock.start();
    t.same(updateNotification.source, clock, "Start notification from clock");
});

test("Stop notification", t => {
    const clock = ManualClock.create();
    let updateNotification = null;
    on(clock, "stop", e => { updateNotification = e; });

    clock.start();
    clock.stop();
    t.same(updateNotification.source, clock, "Stop notification from clock");
});

test("Update notification", t => {
    const clock = ManualClock.create();
    let updateNotification = null;
    on(clock, "update", e => { updateNotification = e; });

    clock.start();
    clock.tick.advance(1);
    t.same(updateNotification.source, clock, "Update notification from clock");
});

test("Stop during update", t => {
    const clock = ManualClock.create();
    let events = [];
    const happen = t => { events.push(t); };
    clock.scheduler.at(happen, 1);
    clock.scheduler.at(happen, 7);
    clock.scheduler.at(happen, 11);
    clock.scheduler.at(happen, 17);
    clock.scheduler.events.add({
        f: () => { clock.stop(); },
        t: 11,
        priority: 1000
    });
    clock.start();
    clock.tick.advance(19);
    t.equal(events, [1, 7], "Updates");
    t.equal(clock.now, 11, "Stop time before the end of the updates");
});

test("Update after stop", t => {
    const clock = ManualClock.create();
    const updates = [];
    on(clock, "update", () => updates.push(clock.now));
    clock.start();
    clock.tick.advance(1);
    clock.tick.skip(1);
    clock.stop();
    clock.tick.advance(0);
    t.equal(updates, [1, 2], "Two updates (first when running, then after stop)");
});

        </script>
    </head>
    <body>
    </body>
</html>
